\hypertarget{classMATOPS_1_1BigMatrix}{}\section{M\+A\+T\+O\+PS\+:\+:Big\+Matrix$<$ Data1 $>$ Class Template Reference}
\label{classMATOPS_1_1BigMatrix}\index{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix$<$ Data1 $>$@{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix$<$ Data1 $>$}}


This is the Class for handling Large Matrices. It takes in large Matrices stored as comma-\/separated values (C\+SV) files and perform both Multiplication (Stressan\textquotesingle{}s Algorithm) and transpose.  




{\ttfamily \#include $<$matrix.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classMATOPS_1_1BigMatrix_a2b3003374e008ff98f763c29aa4e3c07}{Mat\+\_\+print} (std\+::string path)
\begin{DoxyCompactList}\small\item\em Function to print a \hyperlink{classMATOPS_1_1Matrix}{Matrix} from a .csv file. \end{DoxyCompactList}\item 
void \hyperlink{classMATOPS_1_1BigMatrix_a654c6a62d3dec6a4728e56dd361adbf3}{set\+\_\+\+L\+E\+A\+F\+\_\+\+S\+I\+ZE} (int leaf\+\_\+size)
\begin{DoxyCompactList}\small\item\em This Function sets the L\+E\+A\+F\+\_\+\+S\+I\+ZE i.\+e. the array size when we shift from Stressan\textquotesingle{}s Algo to normal O(n$^\wedge$3) solution. The leaf size is used by the Strassen\+Multiply recursive function to manipulate the recursion base condition. Once we reach a square matrix array of size L\+E\+A\+F\+\_\+\+S\+I\+ZE x L\+E\+A\+F\+\_\+\+S\+I\+ZE or lesser, we perform the multiplication using the naive O(n$^\wedge$3) time complexity solution. The value of L\+E\+A\+F\+\_\+\+S\+I\+ZE varies from machine to machine, hence we need to experimentally find out this value for each machine and configure the \hyperlink{matrix_8h}{matrix.\+h} library accordingly. \end{DoxyCompactList}\item 
void \hyperlink{classMATOPS_1_1BigMatrix_a89f5328b2686ef2a0dfaa9c2bd852d37}{set\+\_\+configerd\+\_\+\+Leaf\+\_\+size} ()
\begin{DoxyCompactList}\small\item\em Searches for the configure.\+txt file (generated earlier) and sets the L\+E\+A\+F\+\_\+\+S\+I\+ZE value to the optimal value found out by \hyperlink{configure__lib_8cpp}{configure\+\_\+lib.\+cpp} program during configuration process. This function is called by the \hyperlink{classMATOPS_1_1BigMatrix_ac793236874a8ccfd66e21006011b9cff}{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix$<$\+Data1$>$\+::matmul} before starting the multiplication process. \end{DoxyCompactList}\item 
void \hyperlink{classMATOPS_1_1BigMatrix_ac793236874a8ccfd66e21006011b9cff}{matmul} (std\+::string file\+\_\+1, std\+::string file\+\_\+2, std\+::string path, bool print=false)
\begin{DoxyCompactList}\small\item\em This is the \hyperlink{classMATOPS_1_1BigMatrix}{Big\+Matrix} multiplication Function. To multiply two matrices A and B stored in A.\+csv and B.\+csv respectively and store the result in C.\+csv file. Before brginning the multiplication process it parses the configure.\+txt (generated by \hyperlink{configure__lib_8cpp}{configure\+\_\+lib.\+cpp} during the configuration process) and sets the optimal L\+E\+A\+F\+\_\+\+S\+I\+ZE value. \end{DoxyCompactList}\item 
void \hyperlink{classMATOPS_1_1BigMatrix_a3d3ca40bb701fbc884c6b603dd95e753}{Transpose} (std\+::string path, std\+::string str\+\_\+path)
\begin{DoxyCompactList}\small\item\em This is a function to find the Transpose of a \hyperlink{classMATOPS_1_1BigMatrix}{Big\+Matrix} and stores it in a csv file. \end{DoxyCompactList}\item 
void \hyperlink{classMATOPS_1_1BigMatrix_a1a6d446f0a7e13eae2de1c6702acd706}{Transpose} (std\+::string path)
\begin{DoxyCompactList}\small\item\em This is a function to find the Transpose of a \hyperlink{classMATOPS_1_1BigMatrix}{Big\+Matrix} and stores it in the same csv file (In-\/palce transpose). \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
Data1 $\ast$$\ast$ \hyperlink{classMATOPS_1_1BigMatrix_a2730be4ce100cfdbaf1240703bd9cfb9}{Init\+\_\+matrix} (int n)
\begin{DoxyCompactList}\small\item\em Function to dynamically allocate/initialize an n x n matrix in the memory. \end{DoxyCompactList}\item 
Data1 $\ast$$\ast$ \hyperlink{classMATOPS_1_1BigMatrix_a175eecea05e419357d7475f5e3e938da}{add} (Data1 $\ast$$\ast$M1, Data1 $\ast$$\ast$M2, int n)
\begin{DoxyCompactList}\small\item\em Function to Add 2 square Matrices of size n. \end{DoxyCompactList}\item 
Data1 $\ast$$\ast$ \hyperlink{classMATOPS_1_1BigMatrix_a5c89e7f360fb3cc32abbf6f1d430fb1f}{sub} (Data1 $\ast$$\ast$M1, Data1 $\ast$$\ast$M2, int n)
\begin{DoxyCompactList}\small\item\em Function to Subtract 2 square Matrices of size n. \end{DoxyCompactList}\item 
Data1 $\ast$$\ast$ \hyperlink{classMATOPS_1_1BigMatrix_a71c665c80a1ca3731bd0d8ce37f0ace1}{Strassen\+Multiply} (Data1 $\ast$$\ast$A, Data1 $\ast$$\ast$B, int n)
\begin{DoxyCompactList}\small\item\em The main Strassen\textquotesingle{}s Algorithm function implemented using recursion. Takes in square Matrices A and B. \end{DoxyCompactList}\item 
void \hyperlink{classMATOPS_1_1BigMatrix_af5223558c09e6c3c2fd3bcc5ccd08382}{print\+\_\+\+Mat} (Data1 $\ast$$\ast$C, int m, int n)
\begin{DoxyCompactList}\small\item\em This function is called from within the \hyperlink{classMATOPS_1_1BigMatrix_ac793236874a8ccfd66e21006011b9cff}{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix$<$\+Data1$>$\+::matmul} function when print == True. \end{DoxyCompactList}\item 
std\+::vector$<$ std\+::vector$<$ Data1 $>$ $>$ \hyperlink{classMATOPS_1_1BigMatrix_a43e1704cb38eb6d0121be5b71014eb8e}{load\+\_\+\+C\+SV} (const std\+::string \&path)
\begin{DoxyCompactList}\small\item\em Function to load C\+SV file. This function is internally called by \hyperlink{classMATOPS_1_1BigMatrix_ac793236874a8ccfd66e21006011b9cff}{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix$<$\+Data1$>$\+::matmul} and \hyperlink{classMATOPS_1_1BigMatrix_a3d3ca40bb701fbc884c6b603dd95e753}{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix$<$ Data1 $>$\+::\+Transpose} to load the \hyperlink{classMATOPS_1_1BigMatrix}{Big\+Matrix} \textquotesingle{}s to be multiplied or Transposed. It throws an error if path is invalid or C\+SV doesn\textquotesingle{}t exist. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{classMATOPS_1_1BigMatrix_a3e8820058e3950e17136fd656b97de54}{L\+E\+A\+F\+\_\+\+S\+I\+ZE}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Data1$>$\newline
class M\+A\+T\+O\+P\+S\+::\+Big\+Matrix$<$ Data1 $>$}

This is the Class for handling Large Matrices. It takes in large Matrices stored as comma-\/separated values (C\+SV) files and perform both Multiplication (Stressan\textquotesingle{}s Algorithm) and transpose. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Data1} & = Datatype of the \hyperlink{classMATOPS_1_1BigMatrix}{Big\+Matrix}. Eg. int, float, double etc. \\
\hline
\end{DoxyTemplParams}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classMATOPS_1_1BigMatrix_a175eecea05e419357d7475f5e3e938da}\label{classMATOPS_1_1BigMatrix_a175eecea05e419357d7475f5e3e938da}} 
\index{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix@{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}!add@{add}}
\index{add@{add}!M\+A\+T\+O\+P\+S\+::\+Big\+Matrix@{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}}
\subsubsection{\texorpdfstring{add()}{add()}}
{\footnotesize\ttfamily template$<$typename Data1$>$ \\
Data1$\ast$$\ast$ \hyperlink{classMATOPS_1_1BigMatrix}{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}$<$ Data1 $>$\+::add (\begin{DoxyParamCaption}\item[{Data1 $\ast$$\ast$}]{M1,  }\item[{Data1 $\ast$$\ast$}]{M2,  }\item[{int}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}



Function to Add 2 square Matrices of size n. 


\begin{DoxyParams}{Parameters}
{\em M1} & = \hyperlink{classMATOPS_1_1BigMatrix}{Big\+Matrix} 1 \\
\hline
{\em M2} & = \hyperlink{classMATOPS_1_1BigMatrix}{Big\+Matrix} 2 \\
\hline
{\em n} & = Size of the Matrices \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a pointer pointing to the sum of M1 and M2 
\end{DoxyReturn}

\begin{DoxyCode}
323                         \{
324                                 Data1** temp = \hyperlink{classMATOPS_1_1BigMatrix_a2730be4ce100cfdbaf1240703bd9cfb9}{Init\_matrix}(n);
325                             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<n; i++)
326                                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<n; j++)
327                                     temp[i][j] = M1[i][j] + M2[i][j];
328                             \textcolor{keywordflow}{return} temp;
329                         \}
\end{DoxyCode}
\mbox{\Hypertarget{classMATOPS_1_1BigMatrix_a2730be4ce100cfdbaf1240703bd9cfb9}\label{classMATOPS_1_1BigMatrix_a2730be4ce100cfdbaf1240703bd9cfb9}} 
\index{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix@{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}!Init\+\_\+matrix@{Init\+\_\+matrix}}
\index{Init\+\_\+matrix@{Init\+\_\+matrix}!M\+A\+T\+O\+P\+S\+::\+Big\+Matrix@{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}}
\subsubsection{\texorpdfstring{Init\+\_\+matrix()}{Init\_matrix()}}
{\footnotesize\ttfamily template$<$typename Data1$>$ \\
Data1$\ast$$\ast$ \hyperlink{classMATOPS_1_1BigMatrix}{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}$<$ Data1 $>$\+::Init\+\_\+matrix (\begin{DoxyParamCaption}\item[{int}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}



Function to dynamically allocate/initialize an n x n matrix in the memory. 


\begin{DoxyParams}{Parameters}
{\em n} & = No. of rows and cols of the \hyperlink{classMATOPS_1_1BigMatrix}{Big\+Matrix}. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a pointer pointing to the initialized \hyperlink{classMATOPS_1_1BigMatrix}{Big\+Matrix}. 
\end{DoxyReturn}

\begin{DoxyCode}
303                         \{   \textcolor{comment}{// Calloc chunk of Memory}
304 
305                                 Data1** M;
306                                 M=(Data1 **)calloc(n,\textcolor{keyword}{sizeof}(Data1*)); 
307                                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<n;i++)
308                                 \{
309                                         M[i]=(Data1*)calloc(n,\textcolor{keyword}{sizeof}(Data1));
310                                 \}
311                                 \textcolor{keywordflow}{return} M;
312                         \}
\end{DoxyCode}
\mbox{\Hypertarget{classMATOPS_1_1BigMatrix_a43e1704cb38eb6d0121be5b71014eb8e}\label{classMATOPS_1_1BigMatrix_a43e1704cb38eb6d0121be5b71014eb8e}} 
\index{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix@{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}!load\+\_\+\+C\+SV@{load\+\_\+\+C\+SV}}
\index{load\+\_\+\+C\+SV@{load\+\_\+\+C\+SV}!M\+A\+T\+O\+P\+S\+::\+Big\+Matrix@{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}}
\subsubsection{\texorpdfstring{load\+\_\+\+C\+S\+V()}{load\_CSV()}}
{\footnotesize\ttfamily template$<$typename Data1$>$ \\
std\+::vector$<$std\+::vector$<$Data1$>$ $>$ \hyperlink{classMATOPS_1_1BigMatrix}{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}$<$ Data1 $>$\+::load\+\_\+\+C\+SV (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{path }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}



Function to load C\+SV file. This function is internally called by \hyperlink{classMATOPS_1_1BigMatrix_ac793236874a8ccfd66e21006011b9cff}{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix$<$\+Data1$>$\+::matmul} and \hyperlink{classMATOPS_1_1BigMatrix_a3d3ca40bb701fbc884c6b603dd95e753}{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix$<$ Data1 $>$\+::\+Transpose} to load the \hyperlink{classMATOPS_1_1BigMatrix}{Big\+Matrix} \textquotesingle{}s to be multiplied or Transposed. It throws an error if path is invalid or C\+SV doesn\textquotesingle{}t exist. 


\begin{DoxyParams}{Parameters}
{\em path=} & \char`\"{}path to C\+S\+V file i.\+e. to be loaded\char`\"{} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pointer to the \hyperlink{classMATOPS_1_1Matrix}{Matrix} loaded in memory. 
\end{DoxyReturn}

\begin{DoxyCode}
566                 \{
567                     std::ifstream indata;
568                     indata.open(path);
569 
570                     \textcolor{keywordflow}{if}(indata.fail()) \textcolor{comment}{// Check if File exists}
571                     \{
572                         std::cerr<<\textcolor{stringliteral}{"File path: '"}<<path<<\textcolor{stringliteral}{"' doesn't exist\(\backslash\)n"};
573                         exit(0);
574                     \}
575 
576                     std::vector<std::vector<Data1>> dataList;
577                     std::string line = \textcolor{stringliteral}{""};
578 
579                     \textcolor{keywordflow}{while}(getline(indata,line))
580                     \{
581                         std::stringstream lineStream(line);
582                         std::string cell;
583                         std::vector<Data1> temp;
584                         \textcolor{keywordflow}{while} (std::getline(lineStream,cell,\textcolor{charliteral}{','}))
585                         \{
586                             temp.push\_back(convert\_to<Data1>(cell)); \textcolor{comment}{// convert from string to Data1 and
       store it in an 2D array.}
587                         \}
588                         dataList.push\_back(temp);
589 
590                     \}
591                     indata.close(); \textcolor{comment}{// Close file}
592                     \textcolor{keywordflow}{return} dataList; \textcolor{comment}{// Return the 2D vector }
593                 \}
\end{DoxyCode}
\mbox{\Hypertarget{classMATOPS_1_1BigMatrix_a2b3003374e008ff98f763c29aa4e3c07}\label{classMATOPS_1_1BigMatrix_a2b3003374e008ff98f763c29aa4e3c07}} 
\index{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix@{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}!Mat\+\_\+print@{Mat\+\_\+print}}
\index{Mat\+\_\+print@{Mat\+\_\+print}!M\+A\+T\+O\+P\+S\+::\+Big\+Matrix@{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}}
\subsubsection{\texorpdfstring{Mat\+\_\+print()}{Mat\_print()}}
{\footnotesize\ttfamily template$<$typename Data1$>$ \\
void \hyperlink{classMATOPS_1_1BigMatrix}{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}$<$ Data1 $>$\+::Mat\+\_\+print (\begin{DoxyParamCaption}\item[{std\+::string}]{path }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Function to print a \hyperlink{classMATOPS_1_1Matrix}{Matrix} from a .csv file. 


\begin{DoxyParams}{Parameters}
{\em path} & = \char`\"{}path to .\+csv i.\+e. to be printed\char`\"{} \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
601                 \{
602                         std::vector<std::vector<Data1>> MAT= \hyperlink{classMATOPS_1_1BigMatrix_a43e1704cb38eb6d0121be5b71014eb8e}{load\_CSV}(path);
603 
604                         \textcolor{keywordflow}{for}(std::vector<Data1> a: MAT)
605                         \{
606                                 \textcolor{keywordflow}{for}(Data1 i: a)
607                                 \{
608                                         std::cout<< i <<\textcolor{stringliteral}{" "};
609                                 \}
610                                 std::cout<<\textcolor{charliteral}{'\(\backslash\)n'};
611                         \}
612                 \}
\end{DoxyCode}
\mbox{\Hypertarget{classMATOPS_1_1BigMatrix_ac793236874a8ccfd66e21006011b9cff}\label{classMATOPS_1_1BigMatrix_ac793236874a8ccfd66e21006011b9cff}} 
\index{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix@{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}!matmul@{matmul}}
\index{matmul@{matmul}!M\+A\+T\+O\+P\+S\+::\+Big\+Matrix@{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}}
\subsubsection{\texorpdfstring{matmul()}{matmul()}}
{\footnotesize\ttfamily template$<$typename Data1$>$ \\
void \hyperlink{classMATOPS_1_1BigMatrix}{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}$<$ Data1 $>$\+::matmul (\begin{DoxyParamCaption}\item[{std\+::string}]{file\+\_\+1,  }\item[{std\+::string}]{file\+\_\+2,  }\item[{std\+::string}]{path,  }\item[{bool}]{print = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



This is the \hyperlink{classMATOPS_1_1BigMatrix}{Big\+Matrix} multiplication Function. To multiply two matrices A and B stored in A.\+csv and B.\+csv respectively and store the result in C.\+csv file. Before brginning the multiplication process it parses the configure.\+txt (generated by \hyperlink{configure__lib_8cpp}{configure\+\_\+lib.\+cpp} during the configuration process) and sets the optimal L\+E\+A\+F\+\_\+\+S\+I\+ZE value. 


\begin{DoxyParams}{Parameters}
{\em file\+\_\+1} & = \char`\"{}path to A.\+csv\char`\"{} \\
\hline
{\em file\+\_\+2} & = \char`\"{}path to B.\+csv\char`\"{} \\
\hline
{\em path} & = path to a store file (no need to predefine C.\+csv file in the directory, it gets generated automatically.) \\
\hline
{\em print} & = True, To see all the Matrices i.\+e. A,B and C in the output terminal/stdio. ~\newline
\begin{DoxyVerb} Define a BigMatrix object BigMatrix<DataType> MatObj, where DataType can be int, float, double, long etc.\n
 Then call MatObj.matmul("path/to/A.csv","path/to/B.csv","path/to/C.csv") from your program. The C.csv file generated file contains C=A*B.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
662                                 \{   
663                                         
664 \textcolor{preprocessor}{                                        #ifndef SET\_LEAF\_SIZE }
665                                                 \hyperlink{classMATOPS_1_1BigMatrix_a89f5328b2686ef2a0dfaa9c2bd852d37}{set\_configerd\_Leaf\_size}(); \textcolor{comment}{// Set
       the optimal LEAF\_SIZE by parsing the configuration file genrated by configure\_lib.cpp.}
666 \textcolor{preprocessor}{                                        #endif}
667                                         \textcolor{comment}{// std::cout<<"Current LEAF\_SIZE value: "<<LEAF\_SIZE<<'\(\backslash\)n'; // Just
       a check to see what LEAF\_SIZE value is being used}
668                                         
669                                         \textcolor{comment}{// Parse the CSV files and get the Matrices to be multiplied}
670 
671                                         std::vector<std::vector<Data1>> MAT\_1= 
      \hyperlink{classMATOPS_1_1BigMatrix_a43e1704cb38eb6d0121be5b71014eb8e}{load\_CSV}(file\_1);
672                                         std::vector<std::vector<Data1>> MAT\_2= 
      \hyperlink{classMATOPS_1_1BigMatrix_a43e1704cb38eb6d0121be5b71014eb8e}{load\_CSV}(file\_2);
673 
674                                         \textcolor{comment}{// Get the dimensions of both the Matrices.}
675                                         \textcolor{keywordtype}{int} m\_1=MAT\_1.size(), n\_1=MAT\_1[0].size();  \textcolor{comment}{// Matrix 1 M,N}
676                                         \textcolor{keywordtype}{int} m\_2=MAT\_2.size(), n\_2=MAT\_2[0].size(); \textcolor{comment}{// Matrix 2 M,N}
677 
678                                         \textcolor{keywordflow}{if}(n\_1 != m\_2) \textcolor{comment}{// Check if inner dimensions of the Matrices Match.
       If not then Throw error.}
679                                         \{
680                                                 std::cerr<<\textcolor{stringliteral}{"Matrix Inner Dimensions don't match !!! Matrix
       A dim : "}<<m\_1<<\textcolor{stringliteral}{"x"}<<n\_1<<\textcolor{stringliteral}{" & Matrix B dim : "}<<m\_2<<\textcolor{stringliteral}{"x"}<<n\_2<<\textcolor{stringliteral}{"\(\backslash\)n"};
681                                                 exit(0);
682                                         \}
683                                         \textcolor{keywordflow}{else}  \textcolor{comment}{// Begin Multiplication}
684                                         \{
685                                                 \textcolor{keywordtype}{int} max\_n= std::max(std::max(m\_1,n\_1),n\_2); \textcolor{comment}{// Find the max
       of all the Matrix dimensions, to find the next highest power of 2.}
686                                                 \textcolor{keywordtype}{int} dim\_n=1;
687 
688                                                 \textcolor{comment}{// Find the next highest power of 2 using left shift
       operator (dim\_n = Next highest power of 2).}
689                                                 \textcolor{comment}{// This will be used to pad zeros to both matrices A and B,
       and ultimately given as input to StrassenMultiply() function.}
690                                                 \textcolor{keywordflow}{while}(dim\_n<max\_n)
691                                                 \{
692                                                         dim\_n=dim\_n<<1;
693                                                 \}
694 
695                                                 \textcolor{comment}{// Initialize 3 pointers to point at Matrices A and B, and
       to store the Result of AxB into C.}
696                                                 Data1 ** A;
697                                                 Data1 ** B;
698                                                 Data1 ** C;
699 
700                                                 A=\hyperlink{classMATOPS_1_1BigMatrix_a2730be4ce100cfdbaf1240703bd9cfb9}{Init\_matrix}(dim\_n); \textcolor{comment}{// Allocate the memory for
       Matrix A of size dim\_n}
701                                                 B=\hyperlink{classMATOPS_1_1BigMatrix_a2730be4ce100cfdbaf1240703bd9cfb9}{Init\_matrix}(dim\_n); \textcolor{comment}{// Allocate the memory for
       Matrix B of size dim\_n}
702 
703                                                 \textcolor{comment}{// Build the Zero padded square Matrices A and B}
704                                                         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0;k<m\_1;k++)
705                                                         \{
706                                                                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} l=0;l<n\_1;l++)
707                                                                 \{
708                                                                         A[k][l]= MAT\_1[k][l];
709                                                                 \}
710                                                         \}
711 
712                                                         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0;k<m\_2;k++)
713                                                         \{
714                                                                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} l=0;l<n\_2;l++)
715                                                                 \{
716                                                                         B[k][l]= MAT\_2[k][l];
717 
718                                                                 \}
719 
720                                                         \}
721 
722                                                 \textcolor{comment}{//Call Stressen's Algorithm function to get A x B and store
       in C.}
723                                                         C=\hyperlink{classMATOPS_1_1BigMatrix_a71c665c80a1ca3731bd0d8ce37f0ace1}{StrassenMultiply}(A, B, dim\_n);
724 
725                                         \textcolor{keywordflow}{if}(print==\textcolor{keyword}{true}) \textcolor{comment}{// if print is true then print A, B and the result
       A.}
726                                                 \{
727                                                                 std::cout<<\textcolor{stringliteral}{"A: \(\backslash\)n"};
728                                                                 \hyperlink{classMATOPS_1_1BigMatrix_af5223558c09e6c3c2fd3bcc5ccd08382}{print\_Mat}(A, m\_1, n\_1); \textcolor{comment}{//Call the
       print\_Mat function to print the Matrix}
729 
730                                                                 std::cout<<\textcolor{stringliteral}{"\(\backslash\)nB: \(\backslash\)n"};
731                                                                 \hyperlink{classMATOPS_1_1BigMatrix_af5223558c09e6c3c2fd3bcc5ccd08382}{print\_Mat}(B, m\_2, n\_2); \textcolor{comment}{//Call the
       print\_Mat function to print the Matrix}
732 
733                                                                 std::cout<<\textcolor{stringliteral}{"\(\backslash\)nANSWER: \(\backslash\)n"}; \textcolor{comment}{//Call the
       print\_Mat function to print the Matrix}
734                                                                 \hyperlink{classMATOPS_1_1BigMatrix_af5223558c09e6c3c2fd3bcc5ccd08382}{print\_Mat}(C, m\_1, n\_2);
735 
736                                                 \}
737 
738                                         \textcolor{comment}{// Store the Result C into a CSV file, whose location is given by
       "path"}
739                                                 store\_csv<Data1>(C, m\_1,n\_2,path);
740 
741                                                 \textcolor{comment}{// Free The memory before quitting}
742                                                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<dim\_n;i++)
743                                                 \{
744                                                         free(A[i]);
745                                                         free(B[i]);
746                                                         free(C[i]);
747                                                 \}
748 
749                                                 free(A);
750                                                 free(B);
751                                                 free(C);
752 
753                                         \}
754 
755                                 \} \textcolor{comment}{// matmul function ends here}
\end{DoxyCode}
\mbox{\Hypertarget{classMATOPS_1_1BigMatrix_af5223558c09e6c3c2fd3bcc5ccd08382}\label{classMATOPS_1_1BigMatrix_af5223558c09e6c3c2fd3bcc5ccd08382}} 
\index{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix@{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}!print\+\_\+\+Mat@{print\+\_\+\+Mat}}
\index{print\+\_\+\+Mat@{print\+\_\+\+Mat}!M\+A\+T\+O\+P\+S\+::\+Big\+Matrix@{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}}
\subsubsection{\texorpdfstring{print\+\_\+\+Mat()}{print\_Mat()}}
{\footnotesize\ttfamily template$<$typename Data1$>$ \\
void \hyperlink{classMATOPS_1_1BigMatrix}{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}$<$ Data1 $>$\+::print\+\_\+\+Mat (\begin{DoxyParamCaption}\item[{Data1 $\ast$$\ast$}]{C,  }\item[{int}]{m,  }\item[{int}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}



This function is called from within the \hyperlink{classMATOPS_1_1BigMatrix_ac793236874a8ccfd66e21006011b9cff}{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix$<$\+Data1$>$\+::matmul} function when print == True. 


\begin{DoxyParams}{Parameters}
{\em C} & \\
\hline
{\em m} & \\
\hline
{\em n} & \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
547                         \{
548                                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<m;i++)
549                                 \{
550                                         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0;j<n;j++)
551                                         \{
552                                                 std::cout<<C[i][j]<<\textcolor{stringliteral}{" "};
553                                         \}
554                                         std::cout<<\textcolor{charliteral}{'\(\backslash\)n'};
555                                 \}
556                         \}
\end{DoxyCode}
\mbox{\Hypertarget{classMATOPS_1_1BigMatrix_a89f5328b2686ef2a0dfaa9c2bd852d37}\label{classMATOPS_1_1BigMatrix_a89f5328b2686ef2a0dfaa9c2bd852d37}} 
\index{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix@{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}!set\+\_\+configerd\+\_\+\+Leaf\+\_\+size@{set\+\_\+configerd\+\_\+\+Leaf\+\_\+size}}
\index{set\+\_\+configerd\+\_\+\+Leaf\+\_\+size@{set\+\_\+configerd\+\_\+\+Leaf\+\_\+size}!M\+A\+T\+O\+P\+S\+::\+Big\+Matrix@{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}}
\subsubsection{\texorpdfstring{set\+\_\+configerd\+\_\+\+Leaf\+\_\+size()}{set\_configerd\_Leaf\_size()}}
{\footnotesize\ttfamily template$<$typename Data1$>$ \\
void \hyperlink{classMATOPS_1_1BigMatrix}{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}$<$ Data1 $>$\+::set\+\_\+configerd\+\_\+\+Leaf\+\_\+size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Searches for the configure.\+txt file (generated earlier) and sets the L\+E\+A\+F\+\_\+\+S\+I\+ZE value to the optimal value found out by \hyperlink{configure__lib_8cpp}{configure\+\_\+lib.\+cpp} program during configuration process. This function is called by the \hyperlink{classMATOPS_1_1BigMatrix_ac793236874a8ccfd66e21006011b9cff}{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix$<$\+Data1$>$\+::matmul} before starting the multiplication process. 


\begin{DoxyCode}
637                 \{
638                         std::ifstream indata;
639                         indata.open(\textcolor{stringliteral}{"configure.txt"});
640                         std::string str=\textcolor{stringliteral}{""};
641                         getline(indata,str);
642                         indata.close();
643                         \hyperlink{classMATOPS_1_1BigMatrix_a3e8820058e3950e17136fd656b97de54}{LEAF\_SIZE}=std::stoi(str);
644                 \}
\end{DoxyCode}
\mbox{\Hypertarget{classMATOPS_1_1BigMatrix_a654c6a62d3dec6a4728e56dd361adbf3}\label{classMATOPS_1_1BigMatrix_a654c6a62d3dec6a4728e56dd361adbf3}} 
\index{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix@{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}!set\+\_\+\+L\+E\+A\+F\+\_\+\+S\+I\+ZE@{set\+\_\+\+L\+E\+A\+F\+\_\+\+S\+I\+ZE}}
\index{set\+\_\+\+L\+E\+A\+F\+\_\+\+S\+I\+ZE@{set\+\_\+\+L\+E\+A\+F\+\_\+\+S\+I\+ZE}!M\+A\+T\+O\+P\+S\+::\+Big\+Matrix@{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}}
\subsubsection{\texorpdfstring{set\+\_\+\+L\+E\+A\+F\+\_\+\+S\+I\+Z\+E()}{set\_LEAF\_SIZE()}}
{\footnotesize\ttfamily template$<$typename Data1$>$ \\
void \hyperlink{classMATOPS_1_1BigMatrix}{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}$<$ Data1 $>$\+::set\+\_\+\+L\+E\+A\+F\+\_\+\+S\+I\+ZE (\begin{DoxyParamCaption}\item[{int}]{leaf\+\_\+size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



This Function sets the L\+E\+A\+F\+\_\+\+S\+I\+ZE i.\+e. the array size when we shift from Stressan\textquotesingle{}s Algo to normal O(n$^\wedge$3) solution. The leaf size is used by the Strassen\+Multiply recursive function to manipulate the recursion base condition. Once we reach a square matrix array of size L\+E\+A\+F\+\_\+\+S\+I\+ZE x L\+E\+A\+F\+\_\+\+S\+I\+ZE or lesser, we perform the multiplication using the naive O(n$^\wedge$3) time complexity solution. The value of L\+E\+A\+F\+\_\+\+S\+I\+ZE varies from machine to machine, hence we need to experimentally find out this value for each machine and configure the \hyperlink{matrix_8h}{matrix.\+h} library accordingly. 

The S\+E\+T\+\_\+\+L\+E\+A\+F\+\_\+\+S\+I\+ZE flag is raised by \hyperlink{configure__lib_8cpp}{configure\+\_\+lib.\+cpp} file during execution, thus allowing it to manipulate the L\+E\+A\+F\+\_\+\+S\+I\+ZE (private variable) of the \hyperlink{matrix_8h}{matrix.\+h} file . Hence configure.\+cpp can test the hardware for different values of L\+E\+A\+F\+\_\+\+S\+I\+ZE and pick the optimal L\+E\+A\+F\+\_\+\+S\+I\+ZE value (i.\+e. the one with the lowest execution time) and generate the configure.\+txt file. 
\begin{DoxyCode}
627                 \{
628                         \hyperlink{classMATOPS_1_1BigMatrix_a3e8820058e3950e17136fd656b97de54}{LEAF\_SIZE}=leaf\_size;
629                 \}
\end{DoxyCode}
\mbox{\Hypertarget{classMATOPS_1_1BigMatrix_a71c665c80a1ca3731bd0d8ce37f0ace1}\label{classMATOPS_1_1BigMatrix_a71c665c80a1ca3731bd0d8ce37f0ace1}} 
\index{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix@{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}!Strassen\+Multiply@{Strassen\+Multiply}}
\index{Strassen\+Multiply@{Strassen\+Multiply}!M\+A\+T\+O\+P\+S\+::\+Big\+Matrix@{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}}
\subsubsection{\texorpdfstring{Strassen\+Multiply()}{StrassenMultiply()}}
{\footnotesize\ttfamily template$<$typename Data1$>$ \\
Data1$\ast$$\ast$ \hyperlink{classMATOPS_1_1BigMatrix}{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}$<$ Data1 $>$\+::Strassen\+Multiply (\begin{DoxyParamCaption}\item[{Data1 $\ast$$\ast$}]{A,  }\item[{Data1 $\ast$$\ast$}]{B,  }\item[{int}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}



The main Strassen\textquotesingle{}s Algorithm function implemented using recursion. Takes in square Matrices A and B. 


\begin{DoxyParams}{Parameters}
{\em A} & = \hyperlink{classMATOPS_1_1BigMatrix}{Big\+Matrix} A \\
\hline
{\em B} & = \hyperlink{classMATOPS_1_1BigMatrix}{Big\+Matrix} B \\
\hline
{\em n} & = Size of both A and B \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a square matrix i.\+e. the Multiplication result of A and B. 
\end{DoxyReturn}

\begin{DoxyCode}
356                         \{   
357                                 \textcolor{comment}{/* Naive Stressan's Algorithm (more time consuming)}
358 \textcolor{comment}{                                  if(n==1)}
359 \textcolor{comment}{                                \{}
360 \textcolor{comment}{                                        Data1** C=Init\_matrix(1);}
361 \textcolor{comment}{                                        C[0][0]=A[0][0]*B[0][0];}
362 \textcolor{comment}{                                        return C;}
363 \textcolor{comment}{                                \}*/}
364 
365                                 \textcolor{comment}{// Once array size of LEAF\_SIZE x LEAF\_SIZE or lesser is reached we switch
       to the O(n^3) Matrix Multiplication solution, since after this }
366                                 \textcolor{comment}{// stage the recursion calls become a burden to the whole algorithm and we
       end up getting high execution time. This value of "64" is }
367                                 \textcolor{comment}{// architecture dependent and will vary from machine to machine.}
368                                 \textcolor{keywordflow}{if}(n<=\hyperlink{classMATOPS_1_1BigMatrix_a3e8820058e3950e17136fd656b97de54}{LEAF\_SIZE})
369                                 \{
370                                         Data1** C=\hyperlink{classMATOPS_1_1BigMatrix_a2730be4ce100cfdbaf1240703bd9cfb9}{Init\_matrix}(n);
371                                         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<n;i++)
372                                         \{
373                                                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0;j<n;j++)
374                                                 \{
375                                                         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0;k<n;k++)
376                                                         \{
377                                                                 C[i][j]+=A[i][k]*B[k][j];
378                                                         \}
379                                                 \}
380                                         \}
381                                         \textcolor{keywordflow}{return} C;
382                                 \}
383 
384                                 Data1** C = \hyperlink{classMATOPS_1_1BigMatrix_a2730be4ce100cfdbaf1240703bd9cfb9}{Init\_matrix}(n); \textcolor{comment}{// Initialize an nxn matrix to store
       }
385                                 \textcolor{keywordtype}{int} k = n/2;
386 
387                                 \textcolor{comment}{// Initialize the Block Matrices}
388                                 Data1** A11 = \hyperlink{classMATOPS_1_1BigMatrix_a2730be4ce100cfdbaf1240703bd9cfb9}{Init\_matrix}(k);
389                                 Data1** A12 = \hyperlink{classMATOPS_1_1BigMatrix_a2730be4ce100cfdbaf1240703bd9cfb9}{Init\_matrix}(k);
390                                 Data1** A21 = \hyperlink{classMATOPS_1_1BigMatrix_a2730be4ce100cfdbaf1240703bd9cfb9}{Init\_matrix}(k);
391                                 Data1** A22 = \hyperlink{classMATOPS_1_1BigMatrix_a2730be4ce100cfdbaf1240703bd9cfb9}{Init\_matrix}(k);
392                                 Data1** B11 = \hyperlink{classMATOPS_1_1BigMatrix_a2730be4ce100cfdbaf1240703bd9cfb9}{Init\_matrix}(k);
393                                 Data1** B12 = \hyperlink{classMATOPS_1_1BigMatrix_a2730be4ce100cfdbaf1240703bd9cfb9}{Init\_matrix}(k);
394                                 Data1** B21 = \hyperlink{classMATOPS_1_1BigMatrix_a2730be4ce100cfdbaf1240703bd9cfb9}{Init\_matrix}(k);
395                                 Data1** B22 = \hyperlink{classMATOPS_1_1BigMatrix_a2730be4ce100cfdbaf1240703bd9cfb9}{Init\_matrix}(k);
396 
397                                 \textcolor{comment}{// Build the block Matrices}
398                                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<k;i++)
399                                 \{
400                                         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0;j<k;j++)
401                                         \{
402                                                 A11[i][j] = A[i][j];
403                                                 A12[i][j] = A[i][k+j];
404                                                 A21[i][j] = A[k+i][j];
405                                                 A22[i][j] = A[k+i][k+j];
406                                                 B11[i][j] = B[i][j];
407                                                 B12[i][j] = B[i][k+j];
408                                                 B21[i][j] = B[k+i][j];
409                                                 B22[i][j] = B[k+i][k+j];
410                                         \}
411                                 \}
412                                 \textcolor{comment}{// Determine the Strassen's Coefficients}
413                                 Data1** TEMP\_B12\_B22 = \hyperlink{classMATOPS_1_1BigMatrix_a5c89e7f360fb3cc32abbf6f1d430fb1f}{sub}(B12, B22, k);
414                                 Data1** TEMP\_A11\_A12 = \hyperlink{classMATOPS_1_1BigMatrix_a175eecea05e419357d7475f5e3e938da}{add}(A11, A12, k);
415                                 Data1** TEMP\_A21\_A22 = \hyperlink{classMATOPS_1_1BigMatrix_a175eecea05e419357d7475f5e3e938da}{add}(A21, A22, k);
416                                 Data1** TEMP\_B21\_B11 = \hyperlink{classMATOPS_1_1BigMatrix_a5c89e7f360fb3cc32abbf6f1d430fb1f}{sub}(B21, B11, k);
417 
418 
419                                 Data1** P1 = \hyperlink{classMATOPS_1_1BigMatrix_a71c665c80a1ca3731bd0d8ce37f0ace1}{StrassenMultiply}(A11, TEMP\_B12\_B22, k);
420                                 Data1** P2 = \hyperlink{classMATOPS_1_1BigMatrix_a71c665c80a1ca3731bd0d8ce37f0ace1}{StrassenMultiply}(TEMP\_A11\_A12, B22, k);
421                                 Data1** P3 = \hyperlink{classMATOPS_1_1BigMatrix_a71c665c80a1ca3731bd0d8ce37f0ace1}{StrassenMultiply}(TEMP\_A21\_A22, B11, k);
422                                 Data1** P4 = \hyperlink{classMATOPS_1_1BigMatrix_a71c665c80a1ca3731bd0d8ce37f0ace1}{StrassenMultiply}(A22, TEMP\_B21\_B11, k);
423 
424                                 Data1** TEMP\_A11\_A22 = \hyperlink{classMATOPS_1_1BigMatrix_a175eecea05e419357d7475f5e3e938da}{add}(A11, A22, k);
425                                 Data1** TEMP\_B11\_B22 = \hyperlink{classMATOPS_1_1BigMatrix_a175eecea05e419357d7475f5e3e938da}{add}(B11, B22, k);
426                                 Data1** TEMP\_A12\_A22 = \hyperlink{classMATOPS_1_1BigMatrix_a5c89e7f360fb3cc32abbf6f1d430fb1f}{sub}(A12, A22, k);
427                                 Data1** TEMP\_B21\_B22 = \hyperlink{classMATOPS_1_1BigMatrix_a175eecea05e419357d7475f5e3e938da}{add}(B21, B22, k);
428                                 Data1** TEMP\_A11\_A21 = \hyperlink{classMATOPS_1_1BigMatrix_a5c89e7f360fb3cc32abbf6f1d430fb1f}{sub}(A11, A21, k);
429                                 Data1** TEMP\_B11\_B12 = \hyperlink{classMATOPS_1_1BigMatrix_a175eecea05e419357d7475f5e3e938da}{add}(B11, B12, k);
430 
431                                 Data1** P5 = \hyperlink{classMATOPS_1_1BigMatrix_a71c665c80a1ca3731bd0d8ce37f0ace1}{StrassenMultiply}(TEMP\_A11\_A22, TEMP\_B11\_B22, k
      );
432                                 Data1** P6 = \hyperlink{classMATOPS_1_1BigMatrix_a71c665c80a1ca3731bd0d8ce37f0ace1}{StrassenMultiply}(TEMP\_A12\_A22, TEMP\_B21\_B22, k
      );
433                                 Data1** P7 = \hyperlink{classMATOPS_1_1BigMatrix_a71c665c80a1ca3731bd0d8ce37f0ace1}{StrassenMultiply}(TEMP\_A11\_A21, TEMP\_B11\_B12, k
      );
434 
435                                 Data1** TEMP\_P5\_P4 = \hyperlink{classMATOPS_1_1BigMatrix_a175eecea05e419357d7475f5e3e938da}{add}(P5, P4, k);
436                                 Data1** TEMP\_P5\_P4\_P6 = \hyperlink{classMATOPS_1_1BigMatrix_a175eecea05e419357d7475f5e3e938da}{add}(TEMP\_P5\_P4, P6, k);
437                                 Data1** TEMP\_P5\_P1 = \hyperlink{classMATOPS_1_1BigMatrix_a175eecea05e419357d7475f5e3e938da}{add}(P5, P1, k);
438                                 Data1** TEMP\_P5\_P1\_P3 = \hyperlink{classMATOPS_1_1BigMatrix_a5c89e7f360fb3cc32abbf6f1d430fb1f}{sub}(TEMP\_P5\_P1, P3, k);
439 
440 
441                                 Data1** C11 = \hyperlink{classMATOPS_1_1BigMatrix_a5c89e7f360fb3cc32abbf6f1d430fb1f}{sub}(TEMP\_P5\_P4\_P6, P2, k);
442                                 Data1** C12 = \hyperlink{classMATOPS_1_1BigMatrix_a175eecea05e419357d7475f5e3e938da}{add}(P1, P2, k);
443                                 Data1** C21 = \hyperlink{classMATOPS_1_1BigMatrix_a175eecea05e419357d7475f5e3e938da}{add}(P3, P4, k);
444                                 Data1** C22 = \hyperlink{classMATOPS_1_1BigMatrix_a5c89e7f360fb3cc32abbf6f1d430fb1f}{sub}(TEMP\_P5\_P1\_P3, P7, k);
445 
446                                 \textcolor{comment}{// Building the returning C Matrix}
447 
448                                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<k; i++)
449                                 \{
450                                         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<k; j++)
451                                         \{
452                                                 C[i][j] = C11[i][j];
453                                                 C[i][j+k] = C12[i][j];
454                                                 C[k+i][j] = C21[i][j];
455                                                 C[k+i][k+j] = C22[i][j];
456                                         \}
457                                 \}
458 
459                                 \textcolor{comment}{// Free up all calloced memory.}
460                                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<k; i++) \{
461                                                 free(TEMP\_B12\_B22[i]);
462                                                 free(TEMP\_A11\_A12[i]);
463                                                 free(TEMP\_A21\_A22[i]);
464                                                 free(TEMP\_B21\_B11[i]);
465 
466                                                 free(TEMP\_A11\_A22[i]);
467                                                 free(TEMP\_B11\_B22[i]);
468                                                 free(TEMP\_A12\_A22[i]);
469                                                 free(TEMP\_B21\_B22[i]);
470                                                 free(TEMP\_A11\_A21[i]);
471                                                 free(TEMP\_B11\_B12[i]);
472 
473                                                 free(TEMP\_P5\_P4[i]);
474                                                 free(TEMP\_P5\_P4\_P6[i]);
475                                                 free(TEMP\_P5\_P1[i]);
476                                                 free(TEMP\_P5\_P1\_P3[i]);
477 
478                                         free(A11[i]);
479                                         free(A12[i]);
480                                         free(A21[i]);
481                                         free(A22[i]);
482                                         free(B11[i]);
483                                         free(B12[i]);
484                                         free(B21[i]);
485                                         free(B22[i]);
486                                         free(P1[i]);
487                                         free(P2[i]);
488                                         free(P3[i]);
489                                         free(P4[i]);
490                                         free(P5[i]);
491                                         free(P6[i]);
492                                         free(P7[i]);
493                                         free(C11[i]);
494                                         free(C12[i]);
495                                         free(C21[i]);
496                                         free(C22[i]);
497                                     \}
498 
499                                         free(TEMP\_B12\_B22);
500                                         free(TEMP\_A11\_A12);
501                                         free(TEMP\_A21\_A22);
502                                         free(TEMP\_B21\_B11);
503 
504                                         free(TEMP\_A11\_A22);
505                                         free(TEMP\_B11\_B22);
506                                         free(TEMP\_A12\_A22);
507                                         free(TEMP\_B21\_B22);
508                                         free(TEMP\_A11\_A21);
509                                         free(TEMP\_B11\_B12);
510 
511                                         free(TEMP\_P5\_P4);
512                                         free(TEMP\_P5\_P4\_P6);
513                                         free(TEMP\_P5\_P1);
514                                         free(TEMP\_P5\_P1\_P3);
515 
516                                         free(A11);
517                                     free(A12);
518                                     free(A21);
519                                     free(A22);
520                                     free(B11);
521                                     free(B12);
522                                     free(B21);
523                                     free(B22);
524                                     free(P1);
525                                     free(P2);
526                                     free(P3);
527                                     free(P4);
528                                     free(P5);
529                                     free(P6);
530                                     free(P7);
531                                     free(C11);
532                                     free(C12);
533                                     free(C21);
534                                     free(C22);
535 
536                                     \textcolor{keywordflow}{return} C;
537                         \}
\end{DoxyCode}
\mbox{\Hypertarget{classMATOPS_1_1BigMatrix_a5c89e7f360fb3cc32abbf6f1d430fb1f}\label{classMATOPS_1_1BigMatrix_a5c89e7f360fb3cc32abbf6f1d430fb1f}} 
\index{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix@{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}!sub@{sub}}
\index{sub@{sub}!M\+A\+T\+O\+P\+S\+::\+Big\+Matrix@{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}}
\subsubsection{\texorpdfstring{sub()}{sub()}}
{\footnotesize\ttfamily template$<$typename Data1$>$ \\
Data1$\ast$$\ast$ \hyperlink{classMATOPS_1_1BigMatrix}{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}$<$ Data1 $>$\+::sub (\begin{DoxyParamCaption}\item[{Data1 $\ast$$\ast$}]{M1,  }\item[{Data1 $\ast$$\ast$}]{M2,  }\item[{int}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}



Function to Subtract 2 square Matrices of size n. 


\begin{DoxyParams}{Parameters}
{\em M1} & = \hyperlink{classMATOPS_1_1BigMatrix}{Big\+Matrix} 1 \\
\hline
{\em M2} & = \hyperlink{classMATOPS_1_1BigMatrix}{Big\+Matrix} 2 \\
\hline
{\em n} & = Size of the Matrices \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a pointer pointing to the difference of M1 and M2 
\end{DoxyReturn}

\begin{DoxyCode}
340                         \{
341                                 Data1** temp = \hyperlink{classMATOPS_1_1BigMatrix_a2730be4ce100cfdbaf1240703bd9cfb9}{Init\_matrix}(n);
342                                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<n; i++)
343                                         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<n; j++)
344                                                 temp[i][j] = M1[i][j] - M2[i][j];
345                                 \textcolor{keywordflow}{return} temp;
346                         \}
\end{DoxyCode}
\mbox{\Hypertarget{classMATOPS_1_1BigMatrix_a3d3ca40bb701fbc884c6b603dd95e753}\label{classMATOPS_1_1BigMatrix_a3d3ca40bb701fbc884c6b603dd95e753}} 
\index{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix@{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}!Transpose@{Transpose}}
\index{Transpose@{Transpose}!M\+A\+T\+O\+P\+S\+::\+Big\+Matrix@{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}}
\subsubsection{\texorpdfstring{Transpose()}{Transpose()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Data1$>$ \\
void \hyperlink{classMATOPS_1_1BigMatrix}{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}$<$ Data1 $>$\+::Transpose (\begin{DoxyParamCaption}\item[{std\+::string}]{path,  }\item[{std\+::string}]{str\+\_\+path }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



This is a function to find the Transpose of a \hyperlink{classMATOPS_1_1BigMatrix}{Big\+Matrix} and stores it in a csv file. 


\begin{DoxyParams}{Parameters}
{\em path} & = \char`\"{}path/to/\+A.\+csv\char`\"{} \\
\hline
{\em str\+\_\+path} & = path to store the Transpose of \hyperlink{classMATOPS_1_1BigMatrix}{Big\+Matrix} A. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
767                         \{
768                             std::vector<std::vector<Data1>> MAT= \hyperlink{classMATOPS_1_1BigMatrix_a43e1704cb38eb6d0121be5b71014eb8e}{load\_CSV}(path); \textcolor{comment}{// Load the Matrix
       from CSV file}
769 
770                             Data1** A= (Data1 **)calloc(MAT[0].size(),\textcolor{keyword}{sizeof}(Data1*));
771 
772                             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<MAT[0].size();i++)
773                                 \{
774                                         A[i]=(Data1*)calloc(MAT.size(),\textcolor{keyword}{sizeof}(Data1));
775                                 \}
776 
777                                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<MAT.size();i++)
778                                 \{
779                                         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0;j<MAT[0].size();j++)
780                                         \{
781                                                 A[j][i]=MAT[i][j];
782                                         \}
783                                 \}
784 
785                                 store\_csv<Data1>(A,MAT[0].size(),MAT.size(),str\_path);
786                                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<MAT[0].size();i++)
787                                 \{
788                                         free(A[i]);
789                                 \}
790                                 free(A);
791                         \}
\end{DoxyCode}
\mbox{\Hypertarget{classMATOPS_1_1BigMatrix_a1a6d446f0a7e13eae2de1c6702acd706}\label{classMATOPS_1_1BigMatrix_a1a6d446f0a7e13eae2de1c6702acd706}} 
\index{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix@{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}!Transpose@{Transpose}}
\index{Transpose@{Transpose}!M\+A\+T\+O\+P\+S\+::\+Big\+Matrix@{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}}
\subsubsection{\texorpdfstring{Transpose()}{Transpose()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Data1$>$ \\
void \hyperlink{classMATOPS_1_1BigMatrix}{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}$<$ Data1 $>$\+::Transpose (\begin{DoxyParamCaption}\item[{std\+::string}]{path }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



This is a function to find the Transpose of a \hyperlink{classMATOPS_1_1BigMatrix}{Big\+Matrix} and stores it in the same csv file (In-\/palce transpose). 


\begin{DoxyParams}{Parameters}
{\em path} & = \char`\"{}path/to/\+A.\+csv\char`\"{} \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
798                                         \{
799                                             std::vector<std::vector<Data1>> MAT= 
      \hyperlink{classMATOPS_1_1BigMatrix_a43e1704cb38eb6d0121be5b71014eb8e}{load\_CSV}(path); \textcolor{comment}{// Load the Matrix from CSV file}
800 
801                                             Data1** A= (Data1 **)calloc(MAT[0].size(),\textcolor{keyword}{sizeof}(Data1*));
802 
803                                             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<MAT[0].size();i++)
804                                                 \{
805                                                         A[i]=(Data1*)calloc(MAT.size(),\textcolor{keyword}{sizeof}(Data1));
806                                                 \}
807 
808                                                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<MAT.size();i++)
809                                                 \{
810                                                         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0;j<MAT[0].size();j++)
811                                                         \{
812                                                                 A[j][i]=MAT[i][j];
813                                                         \}
814                                                 \}
815 
816                                                 store\_csv<Data1>(A,MAT[0].size(),MAT.size(),path);
817                                                 store\_csv<Data1>(A,MAT[0].size(),MAT.size(),path);
818 
819                                                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<MAT[0].size();i++)
820                                                 \{
821                                                         free(A[i]);
822                                                 \}
823                                                 free(A);
824 
825                                         \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\mbox{\Hypertarget{classMATOPS_1_1BigMatrix_a3e8820058e3950e17136fd656b97de54}\label{classMATOPS_1_1BigMatrix_a3e8820058e3950e17136fd656b97de54}} 
\index{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix@{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}!L\+E\+A\+F\+\_\+\+S\+I\+ZE@{L\+E\+A\+F\+\_\+\+S\+I\+ZE}}
\index{L\+E\+A\+F\+\_\+\+S\+I\+ZE@{L\+E\+A\+F\+\_\+\+S\+I\+ZE}!M\+A\+T\+O\+P\+S\+::\+Big\+Matrix@{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}}
\subsubsection{\texorpdfstring{L\+E\+A\+F\+\_\+\+S\+I\+ZE}{LEAF\_SIZE}}
{\footnotesize\ttfamily template$<$typename Data1$>$ \\
int \hyperlink{classMATOPS_1_1BigMatrix}{M\+A\+T\+O\+P\+S\+::\+Big\+Matrix}$<$ Data1 $>$\+::L\+E\+A\+F\+\_\+\+S\+I\+ZE\hspace{0.3cm}{\ttfamily [private]}}



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
\hyperlink{matrix_8h}{matrix.\+h}\end{DoxyCompactItemize}
