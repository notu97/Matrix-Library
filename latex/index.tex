This is simple Matrix library to perform Matrix operations namely Matrix Multiplication and Transpose. The library is divided into 2 parts, one for Matrix operations on small Matrices (class Matrix) and other for Large Matrices (class Big\+Matrix). The complete code documentation generated by Doxygen can be found \href{https://notu97.github.io/Matrix-Library/index.html}{\tt here}.

Matrix multiplication for small matrices is done using the straight forward solution with time complexity {\ttfamily O(n$^\wedge$3)}. While for large matrices the Matrix multiplication is done using the Strassen\textquotesingle{}s Algorithm that has Time Complexity of approximatley {\ttfamily O(n$^\wedge$2.8)}.

For Large Matrices the input is taken in a Comma Separated Variable (csv) file format, and the output is stored in a csv file. For small matrices the user has to manually enter the values of the matrix either using a initializer\+\_\+list format or as a 2D vector.

\subsection*{Installation and Configuration}

Inorder to get the best performance from this library for large Matrix Multiplicaiton, one has to experimentally find out and set the {\ttfamily L\+E\+A\+F\+\_\+\+S\+I\+ZE} for the Stressan\textquotesingle{}s Multiplcation function. The {\ttfamily L\+E\+A\+F\+\_\+\+S\+I\+ZE} value modifies the Resursion base condition. Once a Matrix of size {\ttfamily L\+E\+A\+F\+\_\+\+S\+I\+ZE} x {\ttfamily L\+E\+A\+F\+\_\+\+S\+I\+ZE} or lesser is reached we shift to the Native {\ttfamily O(n$^\wedge$3)} Matrix Multiplication solution. The Value of {\ttfamily L\+E\+A\+F\+\_\+\+S\+I\+ZE} has the following effect on the library\+:
\begin{DoxyItemize}
\item A very high value of {\ttfamily L\+E\+A\+F\+\_\+\+S\+I\+ZE} leads to lesser resursion calls but ends up giving more weightage to the {\ttfamily O(n$^\wedge$3)} solution, thus suffer high execution time.
\item On the other hand a very low {\ttfamily L\+E\+A\+F\+\_\+\+S\+I\+ZE} value leads to higher number of resursion calls and gives lesser weightage to the {\ttfamily O(n$^\wedge$3)} solution, which again leads to high execution time.
\end{DoxyItemize}

Both the above scenarios adversely effects the execution time of Matrix Multiplication and added to that the value of optimal {\ttfamily L\+E\+A\+F\+\_\+\+S\+I\+ZE} will vary from machine to machine. Thus we have to experimentally determine the {\ttfamily L\+E\+A\+F\+\_\+\+S\+I\+ZE} value from the computer on which this library will be used. In order to do this a {\ttfamily \hyperlink{configure__lib_8cpp}{configure\+\_\+lib.\+cpp}} file and is provided with this library. This file performs Matrix Multiplication between 2 large matrices A \& B (stored as A.\+csv and B.\+csv in Configure\+\_\+\+Data folder) using the {\ttfamily matmul} function (defined in class {\ttfamily Big\+Matrix}). {\ttfamily Configure\+\_\+lib.\+cpp} performs the multiplication for {\ttfamily N\+\_\+epoch} no. of times for a given {\ttfamily leaf\+\_\+size} and finds the average execution times for this particular {\ttfamily leaf\+\_\+size}. Finally, {\ttfamily \hyperlink{configure__lib_8cpp}{configure\+\_\+lib.\+cpp}} contains an infinite while loop that keeps track of the {\ttfamily leaf\+\_\+size} value and finds out the best/lowest execution time. The {\ttfamily leaf\+\_\+size} value is doubled at every iteration, the while loop breaks out when once the optimal value of {\ttfamily leaf\+\_\+size} is achived and this value is stored in a {\ttfamily configure.\+txt} file. The command to find the optimal {\ttfamily L\+E\+A\+F\+\_\+\+S\+I\+ZE} and generate the {\ttfamily configure.\+txt} is as follows \+:


\begin{DoxyCode}
$ git clone https://github.com/notu97/Matrix-Library.git matrix\_WS
$ cd matrix\_WS/
$ g++ configure\_lib.cpp -o configure\_lib -DSET\_LEAF\_SIZE
$ ./configure\_lib <N\_epoch>
\end{DoxyCode}


Once configuration is complete, just put the {\ttfamily \hyperlink{matrix_8h}{matrix.\+h}} header file in the C++ working directory and include it in the main cpp code using {\ttfamily \#include\char`\"{}matirx.\+h\char`\"{}}. Also please make sure to keep the {\ttfamily configure.\+txt} generated during the configuration step, in the same directory as \char`\"{}matrix.\+h\char`\"{} i.\+e. the C++ working directory. An {\ttfamily \hyperlink{example_8cpp}{example.\+cpp}} template file is provided to get started.

On my computer, for two Matrices A.\+csv and B.\+csv of size 2000x2000 of integer type and {\ttfamily N\+\_\+epoch}= 10 the optimal {\ttfamily L\+E\+A\+F\+\_\+\+S\+I\+ZE} was found out to be {\ttfamily 64} i.\+e. once we encounter an array of size less than or equal to 64x64 we shift to {\ttfamily O(n$^\wedge$3)} solution for Matrix Multiplication. A plot of execution time as a function of {\ttfamily L\+E\+A\+F\+\_\+\+S\+I\+ZE} for my computer is shown below.



\subsection*{Usage}

\subsubsection*{Matrix Class (for small Matrices)}

\paragraph*{Defining a small Matrix of size 3x4 of type float}

Using initilizer list 
\begin{DoxyCode}
MATOPS::Matrix<float,3,4> A\{\{1,2,3,4\},\{5,6,7,8\},\{9,10,11,12\}\};
\end{DoxyCode}


Using 2D std\+::vector 
\begin{DoxyCode}
std::vector<std::vector<float>> vect \{\{1,2,3,4\},\{5,6,7,8\},\{9,10,11,12\}\};
MATOPS::Matrix<float,3,4> A(vect);
\end{DoxyCode}
 Waring\+: The size of small Matrices should not exceed 200 i.\+e. at max we have a matrix of size 200 x 200, else the program stack gets filled with data and there is no space left to do other operations.\textbackslash{}

\#\#\#\# Transposing a small Matrix 
\begin{DoxyCode}
MATOPS::Matrix<float,3,4> A\{\{1,2,3,4\},\{5,6,7,8\},\{9,10,11,12\}\};
std::cout<< A.transpose();
\end{DoxyCode}


\#\#\#\# Multiplying 2 small Matrices 
\begin{DoxyCode}
MATOPS::Matrix<float,3,4> A\{\{1,2,3,4\},\{5,6,7,8\},\{9,10,11,12\}\};
MATOPS::Matrix<float,4,2> B\{\{1,2\},\{5,6\},\{9,10\},\{3,4\}\};
MATOPS::Matrix<float,3,2> C=A*B;

std::cout<< C;
//OR
std::cout<<A*B;
\end{DoxyCode}


\subsubsection*{Big\+Matrix Class (for large Matrices)}

Since big Matrices are already defined in a csv file, we can just parse the files and find out the dimensions of the matrix. The only information to be given to the header file is the Datatype of the Matrix.

\paragraph*{Big\+Matrix Multiply (Strassen\textquotesingle{}s Algorithm)}

Let there be 2 matrices A and B stored in 2 csv files namely A.\+csv and B.\+csv repectively. We wish to multiply both of them and store the result in a third file named Ans.\+csv . The code for this process is shown below.


\begin{DoxyCode}
MATOPS::BigMatrix<float> MatObj; // Defining a Matrix object

// Multiplying the two Matrices A.csv, B.csv and storing the result in Ans.csv
MatObj.matmul("/path/to/A.csv","/path/to/B.csv","/path/to/Ans.csv");

MatObj.Mat\_print("/path/to/Ans.csv"); // Printing the Answer
\end{DoxyCode}
 \paragraph*{Big\+Matrix Transpose}

Given a matrix A in A.\+csv file, we wish to find out its transpose and store it in a new file A\+\_\+trans.\+csv


\begin{DoxyCode}
MATOPS::BigMatrix<float> MatObj; // Defining a Matrix object
MatObj.Transpose("/path/to/A.csv", "/path/to/A\_trans.csv"); // Transposing the matrix and store in a
       A\_trans.csv

MatOnj.Transpose("/path/to/A.csv"); // In-place Matrix transpose.

MatObj.Mat\_print("/path/to/A\_trans.csv"); // Printing the result
\end{DoxyCode}


\subsection*{Example code}

This is an example code to illustrate how to use the library.


\begin{DoxyCode}
#include<iostream>
#include "matrix.h"
#include<vector>

using namespace std;
using namespace MATOPS; //namespace for matrix.h


int main() \{

        // Define matrices of size 2x4 and 2x2 of type double
        Matrix<double,2,4> B\{\{1,2,4,5\},\{4,6,7,8\}\}; 
        Matrix<double,2,2> A\{\{1,2\},\{2,2\}\};

        // Print the Matrices A and B followed by Product A*B and transpose of A
        cout<<A<<"\(\backslash\)n \(\backslash\)n"<<B<<"\(\backslash\)n \(\backslash\)n"<< A*B<<"\(\backslash\)n\(\backslash\)n"<<A.transpose()<<"\(\backslash\)n\(\backslash\)n";

        BigMatrix<float> MatObj; // Define float object for Big Matrix

        // Multiply two Matrices in .csv format and save the result in Ans.csv file.
        MatObj.matmul("/path/to/A.csv","/path/to/B.csv","/path/to/Ans.csv");

        // Read Matrix A from A.csv, find its Transpose and save it in A\_trans.csv
        MatObj.Transpose("/path/to/A.csv", "/path/to/A\_trans.csv");

        // In-place Transpose: Read Matrix A from A.csv, find its Transpose and overwrite A.csv
        MatObj.Transpose("/path/to/A.csv");

        // print Matrix in file A.csv
        MatObj.Mat\_print("/path/to/A.csv");

        return 0;
\}
\end{DoxyCode}
 